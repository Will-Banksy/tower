(*
	EBNF Grammar Syntax:
		Terminals are strings, i.e. "pub" or 'he says "hello"' if quotes need to be included:
			Strings can use backslashes as escape characters and supports common escape sequences
		Nonterminals are identifiers
		Basic syntax: `nonterminal = definition ;`

		A token is a terminal or nonterminal
		In the definition of a nonterminal:
			Tokens come directly after one another with space between, denoting concatenation, e.g. `main_fun = "public" space "static" space "void" space "main"` matches "public static void main"
			Tokens can be grouped with ()
			Tokens can have the following postfix operators applied:
				"x+" - one or more x
				"x*" - zero or more x
				"x?" - zero or one x
			Tokens can have the following infix operators applied:
				"x | y" - x or y
				"x - y" - x that does not match y
			The following constants apply:
				XID_START - Matches any unicode character in the XID_Start class
				XID_CONTINUE - Matches any unicode character in the XID_Continue class
				ALPHA - Matches any unicode alphabetic character
				ALPHANUM - Matches any unicode alphabetic character and "1234567890"
				CHAR - Matches any unicode character
				NUM - Matches any of "1234567890"
				NUM_BIN - Matches any of "01"
				NUM_HEX - Matches any of "1234567890abcdef"
				NUM_OCT - Matches any of "1234567"
			"<? "explanation" ?>" can be used to denote syntax that is highly complex and isn't formalised in the EBNF grammar
*)

module = ( s* function s* )+ ;

function = "fn" s+ identifier s+ block ;

block = "{" ( s* ( identifier | literal ) )* s* "}" ;

(* Same definition of identifiers that Rust uses - derived from unicode rules for identifiers *)
identifier = ( XID_START | "_" ) XID_CONTINUE* ;

literal = literal_string | literal_integer | literal_float ;

(* literal_string = '"' <? "special string handling" ?> '"' ; *)

(* NOTE: Check that this is indeed correct *)
literal_string = '"' ( ( '\' ( '\' | 'n' | 't' | 'r' | '0' | '"' | ( 'x' NUM_HEX NUM_HEX ) ) ) | CHAR - '"' )* '"' ;

literal_integer = "-"? ( "0b" NUM_BIN+ ) | ( "0x" NUM_HEX+ ) | ( "0o" NUM_OCT+ ) | ( NUM+ ) ;

literal_float = "-"? NUM+ ( "." NUM* )? ( ( "e" | "E" ) "-"? NUM+ ) ;

s = ( " " | "\t" | "\n" | "\r" )+ ;